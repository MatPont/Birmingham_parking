library("ARI")
install.packages("ARI", dependencies = TRUE)
install.packages("ari", dependencies = TRUE)
lambdas <- c("10000.0", "1000.0", "100.0", "10.0", "1.0", "0.1", "0.01", "0.001", "0.0001", "1e-05", "0.0")
lambdas <- rev(lambdas)
cos_nmi <- c()
cos_ari <- c()
for(lambda in lambdas){
#file <- paste("result_wc_nmtf/lambda/cos/wc-nmtf_Z_l", lambda, ".csv", sep = "")
file <- paste("result_wc_nmtf/lambda/p_tra/wc-nmtf_Z_l", lambda, "_p_tra.csv", sep = "")
res_wc_nmtf <- read.csv(file, header = TRUE)
res_wc_nmtf <- t( normalize( t(res_wc_nmtf) ) )
label_res <- apply(res_wc_nmtf, MARGIN = 1, FUN=which.max)
t_nmi <- NMI(label_res, labelK)
t_ari <- ARI(label_res, labelK)
cos_nmi <- c(cos_nmi, t_nmi)
cos_ari <- c(cos_ari, t_ari)
}
for(lambda in lambdas){
#file <- paste("result_wc_nmtf/lambda/cos/wc-nmtf_Z_l", lambda, ".csv", sep = "")
file <- paste("result_wc_nmtf/lambda/p_tra/wc-nmtf_Z_l", lambda, "_p_tra.csv", sep = "")
res_wc_nmtf <- read.csv(file, header = TRUE)
res_wc_nmtf <- t( normalize( t(res_wc_nmtf) ) )
label_res <- apply(res_wc_nmtf, MARGIN = 1, FUN=which.max)
t_nmi <- NMI(label_res, labelK)
t_ari <- ARI(label_res, labelK)
cos_nmi <- c(cos_nmi, t_nmi)
cos_ari <- c(cos_ari, t_ari)
}
temp = c(1:10)
matrix(c, nrow = 5)
matrix(temp, nrow = 5)
t <- Sys.time()
t2 <- Sys.time()
t2 - t
temp <- t2 - t
temp
plot(temp)
?dist
?svg
library(fulltext)
install.packages("fulltext", dependencies = TRUE)
plot(1:8)
install.packages("STRINGdb", dependencies = TRUE)
BiocManager::install(STRINGdb)
BiocManager::install("STRINGdb")
BiocManager::install("STRINGdb", update = TRUE)
BiocManager::install("STRINGdb", update = TRUE)
install.packages("BiocManager")
install.packages("BiocManager")
install.packages("BiocManager", dependencies = TRUE)
install.packages("BiocStyle", dependencies = TRUE)
STRINGdb::get_STRING_species()
BiocManager::install("STRINGdb")
library(STRINGdb)
sessionInfo()
plot_network("il4")
library(STRINGdb)
plot_network("il4")
library(FactoMineR)
library(shiny)
library(shinydashboard)
install.packages("shinydashboard")
library(shinydashboard)
ui <- dashboardPage(
dashboardHeader(title = "Dynamic selectInput"),
dashboardSidebar(
sidebarMenu(
menuItemOutput("menuitem")
)
),
dashboardBody(
selectInput("heir1","Heirarchy1",c("NONE","A","B","C"),selected="NONE"),
selectInput("heir2","Heirarchy2",c("NONE","A","B","C"),selected="NONE"),
selectInput("heir3","Heirarchy3",c("NONE","A","B","C"),selected="NONE")
)
)
server <- function(input, output, session) {
output$menuitem <- renderMenu({
menuItem("Menu item", icon = icon("calendar"))
})
heirarchy<-c("A","B","C")
observe({
hei1<-input$heir1
hei2<-input$heir2
hei3<-input$heir3
choice1<-c("NONE",setdiff(heirarchy,c(hei2,hei3)))
choice2<-c("NONE",setdiff(heirarchy,c(hei1,hei3)))
choice3<-c("NONE",setdiff(heirarchy,c(hei1,hei2)))
updateSelectInput(session,"heir1",choices=choice1,selected=hei1)
updateSelectInput(session,"heir2",choices=choice2,selected=hei2)
updateSelectInput(session,"heir3",choices=choice3,selected=hei3)
})
}
shinyApp(ui, server)
library(shiny)
library(shinydashboard)
ui <- dashboardPage(
dashboardHeader(title = "Dynamic selectInput"),
dashboardSidebar(
sidebarMenu(
menuItemOutput("menuitem")
)
),
dashboardBody(
selectInput("heir1","Heirarchy1",c("NONE","A","B","C"),selected="NONE"),
selectInput("heir2","Heirarchy2",c("NONE","A","B","C"),selected="NONE"),
selectInput("heir3","Heirarchy3",c("NONE","A","B","C"),selected="NONE")
)
)
server <- function(input, output, session) {
output$menuitem <- renderMenu({
menuItem("Menu item", icon = icon("calendar"))
})
heirarchy<-c("A","B","C")
observe({
hei1<-input$heir1
hei2<-input$heir2
hei3<-input$heir3
choice1<-c("NONE",setdiff(heirarchy,c(hei2,hei3)))
choice2<-c("NONE",setdiff(heirarchy,c(hei1,hei3)))
choice3<-c("NONE",setdiff(heirarchy,c(hei1,hei2)))
updateSelectInput(session,"heir1",choices=choice1,selected=hei1)
updateSelectInput(session,"heir2",choices=choice2,selected=hei2)
updateSelectInput(session,"heir3",choices=choice3,selected=hei3)
})
}
shinyApp(ui, server)
diag(10)
?svd
svd(diag(10))
library(nbclust)
library(Nbclust)
library(NbClust)
install.packages(NbClust)
install.packages("NbClust", dependencies = TRUE)
library("NbClust")
library(class)
library(MASS)
library(kohonen)
install.packages("kohonen")
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(kohonen)
library(mclust)
library(TSdist)
library(TSclust)
library(cluster)
library(viridis)
library(zoo)
source("util.R")
source("inertia.R")
# Combine som clustering and a clustering on som to produce final clustering
convert_cluster <- function(som_cluster, cluster){
for(i in 1:length(som_cluster)){
for(y in unique(cluster)){
if(som_cluster[i] %in% which(cluster == y)){
som_cluster[i] <- y
break
}
}
}
return(som_cluster)
}
plot_som_temporal <- function(res_som, park_data, park_cluster, mode="week"){
measure_per_day <- 18
measure_per_week <- measure_per_day * 7
num_week <- 11
num_day <- 77
grid_size <- res_som$grid$xdim * res_som$grid$ydim
clusters <- unique(park_cluster)
layout(matrix(1:length(clusters), nrow=1))
for(i in 1:length(clusters)){
centroid <- colMeans(park_data[park_cluster == clusters[i], ])
#color <- t(replicate(grid_size, as.vector(col2rgb("gray88"))))
#color <- t(col2rgb(rev(gray.colors(grid_size, start=0.8, end=0.95))))
color <- matrix(rep(col2rgb("gray88"), grid_size), ncol=3, byrow = TRUE)
if(mode == "week"){
cut <- seq(1, length(centroid)+1, measure_per_week)
num <- num_week
}
else if(mode == "day"){
cut <- seq(1, length(centroid)+1, measure_per_day)
num <- num_day
}
#col <- coolBlueHotRed(num)
col <- viridis(num, alpha=0)
for(i in 1:num){
cluster_vec <- t(as.matrix(centroid[cut[i]:(cut[i+1]-1)]))
pred <- predict(res_som, newdata=cluster_vec)
pred_unit <- pred$unit.classif
color[pred_unit,] <- as.vector(col2rgb(col[i]))
}
plot(res_som, shape="straight", bg=rgb(color/255))
#readline()
}
}
park_data <- read.csv("../Datasets/parking_dataset.csv", row.names = 1)
park_label <- read.csv("../Datasets/parking_dataset_label.csv", row.names = 1)
norm_park_data <- norm_dataset(park_data)
chi_park_data <- norm_chi_2(norm_park_data)
n <- 18
n_chi_park_data=t(apply(chi_park_data, 1, rollapply, n, mean, by = n))
n_norm_park_data=t(apply(norm_park_data, 1, rollapply, n, mean, by = n))
size <- 4
k <- 3
seed <- 3
set.seed(seed)
size <- 4
k <- 4
seed <- 3
set.seed(seed)
res_som = som(n_chi_park_data, grid = somgrid(size, size, "hexagonal"), rlen=1000)
label <- KMedoids(getCodes(res_som), k, distance = "wav")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
plot(res_som,type="counts", palette.name = degrade.bleu, shape="straight")
add.cluster.boundaries(res_som, label, lwd = 5)
dev.off()
if(k %% 2 == 0){  layout(matrix(1:k, nrow=2)) }else{  layout(1:k) }
label <- convert_cluster(res_som$unit.classif, label)
plot_charge_separate(n_norm_park_data, label, "Occupation normalisée")
res_kmeans <- kmeans(getCodes(res_som), k, nstart=50)
label <- res_kmeans$cluster
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
label <- KMedoids(getCodes(res_som), k, distance = "wav")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
label <- KMedoids(getCodes(res_som), k, distance = "wav")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
res_kmeans <- kmeans(getCodes(res_som), k, nstart=50)
label <- res_kmeans$cluster
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
label <- KMedoids(getCodes(res_som), k, distance = "wav")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
seed <- 4
set.seed(seed)
res_som = som(n_chi_park_data, grid = somgrid(size, size, "hexagonal"), rlen=1000)
res_kmeans <- kmeans(getCodes(res_som), k, nstart=50)
label <- res_kmeans$cluster
label <- KMedoids(getCodes(res_som), k, distance = "wav")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
plot(res_som,type="counts", palette.name = degrade.bleu, shape="straight")
add.cluster.boundaries(res_som, label, lwd = 5)
dev.off()
if(k %% 2 == 0){  layout(matrix(1:k, nrow=2)) }else{  layout(1:k) }
label <- convert_cluster(res_som$unit.classif, label)
plot_charge_separate(n_norm_park_data, label, "Occupation normalisée")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
label <- KMedoids(getCodes(res_som), k, distance = "wav")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
label <- KMedoids(getCodes(res_som), k, distance = "wav")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
label <- KMedoids(getCodes(res_som), k, distance = "wav")
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
res_kmeans <- kmeans(getCodes(res_som), k, nstart=50)
label <- res_kmeans$cluster
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
plot(res_som,type="counts", palette.name = degrade.bleu, shape="straight")
add.cluster.boundaries(res_som, label, lwd = 5)
dev.off()
if(k %% 2 == 0){  layout(matrix(1:k, nrow=2)) }else{  layout(1:k) }
label <- convert_cluster(res_som$unit.classif, label)
plot_charge_separate(n_norm_park_data, label, "Occupation normalisée")
plot(res_som,type="counts", palette.name = degrade.bleu, shape="straight")
add.cluster.boundaries(res_som, label, lwd = 5)
res_kmeans <- kmeans(getCodes(res_som), k, nstart=50)
label <- res_kmeans$cluster
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
res_kmeans <- kmeans(getCodes(res_som), k, nstart=50)
label <- res_kmeans$cluster
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
res_kmeans <- kmeans(getCodes(res_som), k, nstart=50)
label <- res_kmeans$cluster
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
plot(res_som,type="counts", palette.name = degrade.bleu, shape="straight")
add.cluster.boundaries(res_som, label, lwd = 5)
dev.off()
if(k %% 2 == 0){  layout(matrix(1:k, nrow=2)) }else{  layout(1:k) }
label <- convert_cluster(res_som$unit.classif, label)
plot_charge_separate(n_norm_park_data, label, "Occupation normalisée")
dev.off()
if(k %% 2 == 0){  layout(matrix(c(4,2,1,3), nrow=2)) }else{  layout(1:k) }
label <- convert_cluster(res_som$unit.classif, label)
plot_charge_separate(n_norm_park_data, label, "Occupation normalisée")
dev.off()
if(k %% 2 == 0){  layout(matrix(c(4,2,1,3), nrow=2)) }else{  layout(1:k) }
label <- convert_cluster(res_som$unit.classif, label)
plot_charge_separate(n_norm_park_data, label, "Occupation normalisée")
matrix(c(4,2,1,3), nrow=2)
unique(label)
res_kmeans <- kmeans(getCodes(res_som), k, nstart=50)
label <- res_kmeans$cluster
dev.off()
plot(res_som, shape="straight", bgcol=MYCOLOR[label])
add.cluster.boundaries(res_som, label, lwd = 3)
plot(res_som,type="counts", palette.name = degrade.bleu, shape="straight")
add.cluster.boundaries(res_som, label, lwd = 5)
dev.off()
if(k %% 2 == 0){  layout(matrix(c(4,2,1,3), nrow=2)) }else{  layout(1:k) }
label <- convert_cluster(res_som$unit.classif, label)
plot_charge_separate(n_norm_park_data, label, "Occupation normalisée")
k <- 5
clus.dwt = KMedoids(data=chi_park_data, k=k, "wav")
dev.off()
if(k %% 2 == 0){  layout(matrix(1:k, nrow=2)) }else{  layout(1:k) }
plot_charge_separate(n_norm_park_data, clus.dwt, ylab = "Occupation normalisée")
plot_charge_separate(n_norm_park_data, clus.dwt, ylab = "Occupation normalisée")
k <- 6
clus.dwt = KMedoids(data=chi_park_data, k=k, "wav")
dev.off()
if(k %% 2 == 0){  layout(matrix(1:k, nrow=2)) }else{  layout(1:k) }
plot_charge_separate(n_norm_park_data, clus.dwt, ylab = "Occupation normalisée")
