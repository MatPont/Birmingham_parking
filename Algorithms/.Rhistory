new_row <- as.matrix(data[idx,])
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
# If different days
if(current_day != next_row_day & difftime(data[idx+1, 5], data[idx, 5], units="hours") > 16) {
new_row = as.matrix(data[idx, ])
# Add row to same day
if(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam")$hour < 16) {
new_row <- as.matrix(data[idx, ])
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
}
# Add row the following day
else {
new_row <- as.matrix(data[idx+1, ])
new_row[5] = as.character(ymd_hms(new_row[5]) - (30*60))
}
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
}
}
newdf <- newdf[-1, ]
return(newdf)
}
# Fill missing days using average on same day but on different week
fill_missing_days <- function(data){
}
# Full data cleaning pipeline
data_cleaning <- function(data){
data <- sort_dataframe(data)
# Remove parking with too few samples
print("Remove parking with too few samples...")
data <- data[data[,1] != "BHMBRTARC01", ]
data <- data[data[,1] != "NIA North", ]
# Remove duplicates
print("Remove duplicates...")
data <- unique(data)
# Round dates
print("Round dates...")
data$LastUpdated <- as.POSIXlt(data$LastUpdated, tz = "Europe/Amsterdam")
data$LastUpdated_rounded <- round_date(data$LastUpdated,'30 minute')
# Manage duplicates after round
print("Manage duplicates after round...")
data <- remove_dates_close(data)
# Manage 7h30 measures
print("Manage 7h30 measures...")
data <- fix_first_measure_of_day(data)
# Manage capacity < occupancy and occupancy < 0
print("Manage capacity < occupancy and occupancy < 0...")
data[data[, 2] < data[, 3], 3] <- data[data[, 2] < data[,3], 2]
data[data[, 3] < 0 ,3] <- rep(0, sum(data[, 3] < 0))
# Add missing values
# TODO
# Fill missing days
# TODO
# Rename rownames
print("Rename rownames...")
data <- sort_dataframe(data)
rownames(data) <- 1:dim(data)[1]
return(data)
}
data <- read.table("../Datasets/dataset.csv", sep=",", header = TRUE)
data <- data_cleaning(data)
add_missing_values(data)
# Create missing rows on the dataframe using average
add_missing_values <- function (data) {
#print("Starting...")
newdf <- rbind(data[1, ])
for (idx in 1:(dim(data)[1]-1)) {
#progress_percent<-as.integer(idx/dim(data)[1]*100)
#progress(progress_percent, progress.bar = FALSE)
current_day <- as.Date(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
next_row_day <- as.Date(as.POSIXlt(data[idx+1, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
# If both parkinglot code are the same
if(data[idx, 1] == data[idx+1, 1]) {
# If same day
if(current_day == next_row_day & difftime(data[idx+1, 5], data[idx, 5], units="mins") > 30) {
if(difftime(data[idx+1, 5], data[idx, 5], units="mins") > 60){
print(difftime(data[idx+1, 5], data[idx, 5], units="mins"))
print(data[idx+1, 5])
print(data[idx, 5])
readline()
}
# Add row
new_row <- as.matrix(data[idx,])
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
# If different days
if(current_day != next_row_day & difftime(data[idx+1, 5], data[idx, 5], units="hours") > 16) {
new_row = as.matrix(data[idx, ])
# Add row to same day
if(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam")$hour < 16) {
new_row <- as.matrix(data[idx, ])
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
}
# Add row the following day
else {
new_row <- as.matrix(data[idx+1, ])
new_row[5] = as.character(ymd_hms(new_row[5]) - (30*60))
}
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
}
}
newdf <- newdf[-1, ]
return(newdf)
}
add_missing_values(data)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(lubridate)
source("util.R")
# After the round of the dates some of them are equals (eg: 7h50 and 8h10 will be round to 8h)
# This function fix this problem by keeping the one with the original date closest to the rounded one
remove_dates_close <- function(data){
row_to_delete <- c()
for(i in 1:(length(data[, 5])-1)){
rounded_date_1 = data[i, 5]
rounded_date_2 = data[i+1, 5]
if(data[i, 1] == data[i+1, 1] && rounded_date_1 == rounded_date_2){
# Check closest date to the rounded one to keep it
if(abs(difftime(rounded_date_1, data[i, 4])) < abs(difftime(rounded_date_2, data[i+1, 4]))){
row_to_delete <- c(row_to_delete, i)
}else{
row_to_delete <- c(row_to_delete, (i+1))
}
}
}
data <- data[-row_to_delete, ]
return(data)
}
# After the round of the dates some of them equals 7h30 but we want to start at 8h
# This function fix this problem by replacing 7h30 with 8h if the measure corresponding of 8h is missing
fix_first_measure_of_day <- function(data){
row_to_delete <- c()
rownames(data) <- 1:dim(data)[1]
temp <- as.numeric(rownames(data[(data[,5]$min == 30) & (data[,5]$hour == 7),]))
temp2 <- as.numeric(rownames(data[(data[,5]$min == 30) & (data[,5]$hour == 7),]))+1
for(i in 1:length(temp)){
idx <- temp[i]
idx2 <- temp2[i]
if( ! (data[idx2,5]$hour == 8 & data[idx2,5]$min == 0)){
data[idx,5] <- data[idx,5] + 30*60
}else{
row_to_delete <- c(row_to_delete, idx)
}
}
data <- data[-row_to_delete, ]
return(data)
}
# Sort by name and rounded date
sort_dataframe <- function(data){
return(data[order(data[,1], data[,dim(data)[2]]), ])
}
# Create missing rows on the dataframe using average
add_missing_values <- function (data) {
#print("Starting...")
newdf <- rbind(data[1, ])
for (idx in 1:(dim(data)[1]-1)) {
#progress_percent<-as.integer(idx/dim(data)[1]*100)
#progress(progress_percent, progress.bar = FALSE)
current_day <- as.Date(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
next_row_day <- as.Date(as.POSIXlt(data[idx+1, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
# If both parkinglot code are the same
if(data[idx, 1] == data[idx+1, 1]) {
# If same day
if(current_day == next_row_day & difftime(data[idx+1, 5], data[idx, 5], units="mins") > 30) {
if(difftime(data[idx+1, 5], data[idx, 5], units="mins") > 60){
print(difftime(data[idx+1, 5], data[idx, 5], units="mins"))
print(data[idx+1, 5])
print(data[idx, 5])
readline()
}
# Add row
new_row <- as.matrix(data[idx,])
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
# If different days
if(current_day != next_row_day & difftime(data[idx+1, 5], data[idx, 5], units="hours") > 16) {
new_row = as.matrix(data[idx, ])
# Add row to same day
if(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam")$hour < 16) {
new_row <- as.matrix(data[idx, ])
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
}
# Add row the following day
else {
new_row <- as.matrix(data[idx+1, ])
new_row[5] = as.character(ymd_hms(new_row[5]) - (30*60))
}
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
}
}
newdf <- newdf[-1, ]
return(newdf)
}
# Fill missing days using average on same day but on different week
fill_missing_days <- function(data){
}
# Full data cleaning pipeline
data_cleaning <- function(data){
data <- sort_dataframe(data)
# Remove parking with too few samples
print("Remove parking with too few samples...")
data <- data[data[,1] != "BHMBRTARC01", ]
data <- data[data[,1] != "NIA North", ]
# Remove duplicates
print("Remove duplicates...")
data <- unique(data)
# Round dates
print("Round dates...")
data$LastUpdated <- as.POSIXlt(data$LastUpdated, tz = "Europe/Amsterdam")
data$LastUpdated_rounded <- round_date(data$LastUpdated,'30 minute')
# Manage duplicates after round
print("Manage duplicates after round...")
data <- remove_dates_close(data)
# Manage 7h30 measures
print("Manage 7h30 measures...")
data <- fix_first_measure_of_day(data)
# Manage capacity < occupancy and occupancy < 0
print("Manage capacity < occupancy and occupancy < 0...")
data[data[, 2] < data[, 3], 3] <- data[data[, 2] < data[,3], 2]
data[data[, 3] < 0 ,3] <- rep(0, sum(data[, 3] < 0))
# Add missing values
# TODO
# Fill missing days
# TODO
# Rename rownames
print("Rename rownames...")
data <- sort_dataframe(data)
rownames(data) <- 1:dim(data)[1]
return(data)
}
data <- read.table("../Datasets/dataset.csv", sep=",", header = TRUE)
data <- data_cleaning(data)
add_missing_values(data)
60%%30
90%%30
60/30
dim(data)
# Create missing rows on the dataframe using average
add_missing_values <- function (data) {
#print("Starting...")
newdf <- rbind(data[1, ])
for (idx in 1:(dim(data)[1]-1)) {
#progress_percent<-as.integer(idx/dim(data)[1]*100)
#progress(progress_percent, progress.bar = FALSE)
current_day <- as.Date(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
next_row_day <- as.Date(as.POSIXlt(data[idx+1, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
# If both parkinglot code are the same
if(data[idx, 1] == data[idx+1, 1]) {
# If same day
time_diff <- difftime(data[idx+1, 5], data[idx, 5], units="mins")
if(current_day == next_row_day & time_diff > 30) {
row_to_add <- as.integer((time_diff-30)/30)
for(i in 1:row_to_add){
# Add row
new_row <- as.matrix(data[idx,])
new_row[3] = as.integer( i*(data[idx, 3] + data[idx+1, 3])/(row_to_add+1)) )
new_row[5] = as.character(ymd_hms(new_row[5]) + (i*30*60))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
}
if(row_to_add != 1){
print(row_to_add)
print(data[idx+1, 5])
print(data[idx, 5])
readline()
}
next
}
# If different days
if(current_day != next_row_day & difftime(data[idx+1, 5], data[idx, 5], units="hours") > 16) {
new_row = as.matrix(data[idx, ])
# Add row to same day
if(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam")$hour < 16) {
new_row <- as.matrix(data[idx, ])
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
}
# Add row the following day
else {
new_row <- as.matrix(data[idx+1, ])
new_row[5] = as.character(ymd_hms(new_row[5]) - (30*60))
}
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
}
}
newdf <- newdf[-1, ]
return(newdf)
}
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(lubridate)
source("util.R")
# After the round of the dates some of them are equals (eg: 7h50 and 8h10 will be round to 8h)
# This function fix this problem by keeping the one with the original date closest to the rounded one
remove_dates_close <- function(data){
row_to_delete <- c()
for(i in 1:(length(data[, 5])-1)){
rounded_date_1 = data[i, 5]
rounded_date_2 = data[i+1, 5]
if(data[i, 1] == data[i+1, 1] && rounded_date_1 == rounded_date_2){
# Check closest date to the rounded one to keep it
if(abs(difftime(rounded_date_1, data[i, 4])) < abs(difftime(rounded_date_2, data[i+1, 4]))){
row_to_delete <- c(row_to_delete, i)
}else{
row_to_delete <- c(row_to_delete, (i+1))
}
}
}
data <- data[-row_to_delete, ]
return(data)
}
# After the round of the dates some of them equals 7h30 but we want to start at 8h
# This function fix this problem by replacing 7h30 with 8h if the measure corresponding of 8h is missing
fix_first_measure_of_day <- function(data){
row_to_delete <- c()
rownames(data) <- 1:dim(data)[1]
temp <- as.numeric(rownames(data[(data[,5]$min == 30) & (data[,5]$hour == 7),]))
temp2 <- as.numeric(rownames(data[(data[,5]$min == 30) & (data[,5]$hour == 7),]))+1
for(i in 1:length(temp)){
idx <- temp[i]
idx2 <- temp2[i]
if( ! (data[idx2,5]$hour == 8 & data[idx2,5]$min == 0)){
data[idx,5] <- data[idx,5] + 30*60
}else{
row_to_delete <- c(row_to_delete, idx)
}
}
data <- data[-row_to_delete, ]
return(data)
}
# Sort by name and rounded date
sort_dataframe <- function(data){
return(data[order(data[,1], data[,dim(data)[2]]), ])
}
# Create missing rows on the dataframe using average
add_missing_values <- function (data) {
#print("Starting...")
newdf <- rbind(data[1, ])
for (idx in 1:(dim(data)[1]-1)) {
#progress_percent<-as.integer(idx/dim(data)[1]*100)
#progress(progress_percent, progress.bar = FALSE)
current_day <- as.Date(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
next_row_day <- as.Date(as.POSIXlt(data[idx+1, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
# If both parkinglot code are the same
if(data[idx, 1] == data[idx+1, 1]) {
# If same day
time_diff <- difftime(data[idx+1, 5], data[idx, 5], units="mins")
if(current_day == next_row_day & time_diff > 30) {
row_to_add <- as.integer((time_diff-30)/30)
for(i in 1:row_to_add){
# Add row
new_row <- as.matrix(data[idx,])
new_row[3] = as.integer( i*(data[idx, 3] + data[idx+1, 3])/(row_to_add+1)) )
new_row[5] = as.character(ymd_hms(new_row[5]) + (i*30*60))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
}
if(row_to_add != 1){
print(row_to_add)
print(data[idx+1, 5])
print(data[idx, 5])
readline()
}
next
}
# If different days
if(current_day != next_row_day & difftime(data[idx+1, 5], data[idx, 5], units="hours") > 16) {
new_row = as.matrix(data[idx, ])
# Add row to same day
if(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam")$hour < 16) {
new_row <- as.matrix(data[idx, ])
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
}
# Add row the following day
else {
new_row <- as.matrix(data[idx+1, ])
new_row[5] = as.character(ymd_hms(new_row[5]) - (30*60))
}
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
}
}
newdf <- newdf[-1, ]
return(newdf)
}
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(lubridate)
source("util.R")
# After the round of the dates some of them are equals (eg: 7h50 and 8h10 will be round to 8h)
# This function fix this problem by keeping the one with the original date closest to the rounded one
remove_dates_close <- function(data){
row_to_delete <- c()
for(i in 1:(length(data[, 5])-1)){
rounded_date_1 = data[i, 5]
rounded_date_2 = data[i+1, 5]
if(data[i, 1] == data[i+1, 1] && rounded_date_1 == rounded_date_2){
# Check closest date to the rounded one to keep it
if(abs(difftime(rounded_date_1, data[i, 4])) < abs(difftime(rounded_date_2, data[i+1, 4]))){
row_to_delete <- c(row_to_delete, i)
}else{
row_to_delete <- c(row_to_delete, (i+1))
}
}
}
data <- data[-row_to_delete, ]
return(data)
}
# After the round of the dates some of them equals 7h30 but we want to start at 8h
# This function fix this problem by replacing 7h30 with 8h if the measure corresponding of 8h is missing
fix_first_measure_of_day <- function(data){
row_to_delete <- c()
rownames(data) <- 1:dim(data)[1]
temp <- as.numeric(rownames(data[(data[,5]$min == 30) & (data[,5]$hour == 7),]))
temp2 <- as.numeric(rownames(data[(data[,5]$min == 30) & (data[,5]$hour == 7),]))+1
for(i in 1:length(temp)){
idx <- temp[i]
idx2 <- temp2[i]
if( ! (data[idx2,5]$hour == 8 & data[idx2,5]$min == 0)){
data[idx,5] <- data[idx,5] + 30*60
}else{
row_to_delete <- c(row_to_delete, idx)
}
}
data <- data[-row_to_delete, ]
return(data)
}
# Sort by name and rounded date
sort_dataframe <- function(data){
return(data[order(data[,1], data[,dim(data)[2]]), ])
}
# Create missing rows on the dataframe using average
add_missing_values <- function (data) {
#print("Starting...")
newdf <- rbind(data[1, ])
for (idx in 1:(dim(data)[1]-1)) {
#progress_percent<-as.integer(idx/dim(data)[1]*100)
#progress(progress_percent, progress.bar = FALSE)
current_day <- as.Date(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
next_row_day <- as.Date(as.POSIXlt(data[idx+1, 5], tz = "Europe/Amsterdam"), "%Y-%m-%d")
# If both parkinglot code are the same
if(data[idx, 1] == data[idx+1, 1]) {
# If same day
time_diff <- difftime(data[idx+1, 5], data[idx, 5], units="mins")
if(current_day == next_row_day & time_diff > 30) {
row_to_add <- as.integer((time_diff-30)/30)
for(i in 1:row_to_add){
# Add row
new_row <- as.matrix(data[idx,])
new_row[3] = as.integer( i*(data[idx, 3] + data[idx+1, 3])/(row_to_add+1)) )
new_row[5] = as.character(ymd_hms(new_row[5]) + (i*30*60))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
}
if(row_to_add != 1){
print(row_to_add)
print(data[idx+1, 5])
print(data[idx, 5])
readline()
}
next
}
# If different days
if(current_day != next_row_day & difftime(data[idx+1, 5], data[idx, 5], units="hours") > 16) {
new_row = as.matrix(data[idx, ])
# Add row to same day
if(as.POSIXlt(data[idx, 5], tz = "Europe/Amsterdam")$hour < 16) {
new_row <- as.matrix(data[idx, ])
new_row[5] = as.character(ymd_hms(new_row[5]) + (30*60))
}
# Add row the following day
else {
new_row <- as.matrix(data[idx+1, ])
new_row[5] = as.character(ymd_hms(new_row[5]) - (30*60))
}
new_row[3] = as.integer(mean(c(data[idx, 3], data[idx+1, 3])))
new_row[4] <- new_row[5]
newdf <- rbind(newdf, new_row)
next
}
}
}
newdf <- newdf[-1, ]
return(newdf)
}
